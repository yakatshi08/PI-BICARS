# Fichier: C:\PROJETS-DEVELOPPEMENT\Analyse_Donnees_CLEAN\project\backend\app\api\v1\endpoints\ai_copilot.py

from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel
from typing import List, Optional, Dict, Any
from datetime import datetime
import json
import re
from enum import Enum

router = APIRouter()

# Mod√®les Pydantic
class QueryType(str, Enum):
    BANKING = "banking"
    INSURANCE = "insurance"
    RISK = "risk"
    GENERAL = "general"

class AIQuery(BaseModel):
    query: str
    context: Optional[str] = "all"
    include_data: Optional[bool] = True
    
class AIResponse(BaseModel):
    response: str
    type: str
    data: Optional[Dict[str, Any]] = None
    suggestions: Optional[List[str]] = None
    timestamp: datetime

class FinancialMetrics(BaseModel):
    cet1_ratio: float
    lcr_ratio: float
    nsfr_ratio: float
    npl_ratio: float
    roe: float
    
class InsuranceMetrics(BaseModel):
    scr_ratio: float
    mcr_ratio: float
    combined_ratio: float
    loss_ratio: float
    expense_ratio: float

# Base de connaissances simplifi√©e
KNOWLEDGE_BASE = {
    "banking": {
        "ratios": {
            "cet1": {
                "current": 14.8,
                "minimum": 10.5,
                "trend": "increasing",
                "description": "Common Equity Tier 1 - Mesure la solidit√© financi√®re"
            },
            "lcr": {
                "current": 125.5,
                "minimum": 100,
                "trend": "stable",
                "description": "Liquidity Coverage Ratio - Capacit√© √† faire face aux sorties de tr√©sorerie"
            },
            "nsfr": {
                "current": 112.3,
                "minimum": 100,
                "trend": "increasing",
                "description": "Net Stable Funding Ratio - Financement stable √† long terme"
            }
        }
    },
    "insurance": {
        "solvency": {
            "scr": {
                "current": 168,
                "minimum": 100,
                "capital_required": 1150000000,
                "own_funds": 1932000000
            },
            "mcr": {
                "current": 672,
                "minimum": 100,
                "capital_required": 287500000
            }
        },
        "performance": {
            "combined_ratio": 94.5,
            "loss_ratio": 62.3,
            "expense_ratio": 32.2
        }
    }
}

def analyze_query(query: str) -> QueryType:
    """D√©termine le type de requ√™te bas√© sur des mots-cl√©s"""
    query_lower = query.lower()
    
    banking_keywords = ["cet1", "tier 1", "lcr", "nsfr", "npl", "b√¢le", "basel", "liquidit√© bancaire"]
    insurance_keywords = ["solvency", "scr", "mcr", "combined ratio", "loss ratio", "actuariel", "provisions techniques"]
    risk_keywords = ["var", "cvar", "stress test", "risque", "anomalie", "fraude"]
    
    if any(keyword in query_lower for keyword in banking_keywords):
        return QueryType.BANKING
    elif any(keyword in query_lower for keyword in insurance_keywords):
        return QueryType.INSURANCE
    elif any(keyword in query_lower for keyword in risk_keywords):
        return QueryType.RISK
    else:
        return QueryType.GENERAL

def generate_banking_response(query: str) -> Dict[str, Any]:
    """G√©n√®re une r√©ponse pour les requ√™tes bancaires"""
    response = {
        "text": "",
        "data": {},
        "type": "banking"
    }
    
    if "cet1" in query.lower() or "tier 1" in query.lower():
        metrics = KNOWLEDGE_BASE["banking"]["ratios"]["cet1"]
        response["text"] = f"""D'apr√®s les derni√®res donn√©es disponibles :

**Ratio CET1 (Common Equity Tier 1)**
‚Ä¢ Ratio actuel : {metrics['current']}%
‚Ä¢ Minimum r√©glementaire : {metrics['minimum']}%
‚Ä¢ Marge de s√©curit√© : +{metrics['current'] - metrics['minimum']:.1f}%

üìä √âvolution : Tendance {metrics['trend']}
‚úÖ **Statut** : Conforme aux exigences B√¢le III

üí° **Recommandation** : Maintenir le ratio au-dessus de 14% pour conserver une marge confortable."""
        
        response["data"] = {
            "cet1_ratio": metrics['current'],
            "minimum": metrics['minimum'],
            "margin": metrics['current'] - metrics['minimum'],
            "status": "compliant"
        }
    
    elif "lcr" in query.lower():
        metrics = KNOWLEDGE_BASE["banking"]["ratios"]["lcr"]
        response["text"] = f"""**Liquidity Coverage Ratio (LCR)**

‚Ä¢ Ratio actuel : {metrics['current']}%
‚Ä¢ Minimum r√©glementaire : {metrics['minimum']}%
‚Ä¢ Exc√©dent de liquidit√© : +{metrics['current'] - metrics['minimum']:.1f}%

üìà Position de liquidit√© solide permettant de couvrir les sorties de tr√©sorerie sur 30 jours."""
        
        response["data"] = {
            "lcr_ratio": metrics['current'],
            "minimum": metrics['minimum'],
            "excess": metrics['current'] - metrics['minimum']
        }
    
    return response

def generate_insurance_response(query: str) -> Dict[str, Any]:
    """G√©n√®re une r√©ponse pour les requ√™tes d'assurance"""
    response = {
        "text": "",
        "data": {},
        "type": "insurance"
    }
    
    if "solvency" in query.lower() or "scr" in query.lower():
        solvency = KNOWLEDGE_BASE["insurance"]["solvency"]
        response["text"] = f"""**Analyse Solvency II - Ratios de solvabilit√©**

üìä **SCR (Solvency Capital Requirement)**
‚Ä¢ Ratio de couverture SCR : {solvency['scr']['current']}%
‚Ä¢ Minimum r√©glementaire : {solvency['scr']['minimum']}%
‚Ä¢ Capital requis : {solvency['scr']['capital_required']/1e9:.2f}B‚Ç¨
‚Ä¢ Fonds propres : {solvency['scr']['own_funds']/1e9:.2f}B‚Ç¨

üìà **MCR (Minimum Capital Requirement)**
‚Ä¢ Ratio de couverture MCR : {solvency['mcr']['current']}%
‚Ä¢ Minimum r√©glementaire : {solvency['mcr']['minimum']}%

‚úÖ Position de solvabilit√© solide avec des marges confortables"""
        
        response["data"] = {
            "scr_ratio": solvency['scr']['current'],
            "mcr_ratio": solvency['mcr']['current'],
            "own_funds": solvency['scr']['own_funds'],
            "scr_requirement": solvency['scr']['capital_required']
        }
    
    elif "combined ratio" in query.lower():
        perf = KNOWLEDGE_BASE["insurance"]["performance"]
        response["text"] = f"""**Analyse du Combined Ratio**

‚Ä¢ Combined Ratio actuel : {perf['combined_ratio']}%
‚Ä¢ Loss Ratio : {perf['loss_ratio']}%
‚Ä¢ Expense Ratio : {perf['expense_ratio']}%

‚úÖ Performance technique excellente (< 100%)
üìä Marge technique : {100 - perf['combined_ratio']:.1f}%"""
        
        response["data"] = perf
    
    return response

def generate_suggestions(query_type: QueryType) -> List[str]:
    """G√©n√®re des suggestions contextuelles"""
    suggestions_map = {
        QueryType.BANKING: [
            "Analyser l'√©volution du ratio NSFR",
            "G√©n√©rer un stress test de liquidit√©",
            "Comparer les ratios avec les pairs du secteur",
            "Pr√©parer le rapport COREP"
        ],
        QueryType.INSURANCE: [
            "D√©composer le SCR par module de risque",
            "Analyser l'√©volution du combined ratio",
            "Calculer les provisions techniques",
            "G√©n√©rer le rapport QRT Solvency II"
        ],
        QueryType.RISK: [
            "Calculer la VaR sur le portefeuille",
            "Lancer une d√©tection d'anomalies",
            "Analyser les corr√©lations de risque",
            "Simuler des sc√©narios de stress"
        ],
        QueryType.GENERAL: [
            "Explorer les donn√©es disponibles",
            "G√©n√©rer un rapport personnalis√©",
            "Analyser les tendances r√©centes",
            "Comparer les performances"
        ]
    }
    
    return suggestions_map.get(query_type, suggestions_map[QueryType.GENERAL])

@router.post("/query", response_model=AIResponse)
async def process_ai_query(query: AIQuery):
    """
    Traite une requ√™te en langage naturel et retourne une r√©ponse intelligente
    """
    try:
        # Analyser le type de requ√™te
        query_type = analyze_query(query.query)
        
        # G√©n√©rer la r√©ponse appropri√©e
        if query_type == QueryType.BANKING:
            result = generate_banking_response(query.query)
        elif query_type == QueryType.INSURANCE:
            result = generate_insurance_response(query.query)
        else:
            # R√©ponse g√©n√©rique pour les autres types
            result = {
                "text": f"J'ai bien compris votre demande concernant '{query.query}'. Je suis en train d'analyser les donn√©es pertinentes.",
                "data": None,
                "type": "general"
            }
        
        # Pr√©parer la r√©ponse finale
        response = AIResponse(
            response=result["text"],
            type=result["type"],
            data=result.get("data"),
            suggestions=generate_suggestions(query_type),
            timestamp=datetime.now()
        )
        
        return response
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/suggestions/{context}")
async def get_contextual_suggestions(context: str):
    """
    Retourne des suggestions bas√©es sur le contexte
    """
    context_suggestions = {
        "banking": [
            {"text": "Calcule mon ratio CET1", "icon": "building"},
            {"text": "Analyse de liquidit√© LCR", "icon": "droplet"},
            {"text": "Stress test B√¢le III", "icon": "alert"}
        ],
        "insurance": [
            {"text": "Ratio SCR Solvency II", "icon": "shield"},
            {"text": "Analyse Combined Ratio", "icon": "chart"},
            {"text": "Calcul provisions techniques", "icon": "calculator"}
        ],
        "all": [
            {"text": "Vue d'ensemble des risques", "icon": "eye"},
            {"text": "Rapport r√©glementaire", "icon": "file"},
            {"text": "D√©tection d'anomalies", "icon": "alert"}
        ]
    }
    
    return context_suggestions.get(context, context_suggestions["all"])

@router.post("/generate-report")
async def generate_report(report_type: str, period: str):
    """
    G√©n√®re un rapport automatis√© bas√© sur le type demand√©
    """
    report_types = {
        "corep": "Common Reporting (COREP) - Reporting prudentiel bancaire",
        "qrt": "Quantitative Reporting Templates - Solvency II",
        "stress_test": "Stress Test BCE - Tests de r√©sistance",
        "ifrs9": "IFRS 9 - Provisions pour pertes de cr√©dit attendues"
    }
    
    if report_type not in report_types:
        raise HTTPException(status_code=400, detail="Type de rapport non reconnu")
    
    # Simulation de g√©n√©ration de rapport
    return {
        "status": "success",
        "report_type": report_type,
        "description": report_types[report_type],
        "period": period,
        "generated_at": datetime.now(),
        "download_url": f"/api/v1/reports/download/{report_type}_{period}.pdf"
    }

@router.get("/metrics/banking")
async def get_banking_metrics() -> FinancialMetrics:
    """Retourne les m√©triques bancaires actuelles"""
    return FinancialMetrics(
        cet1_ratio=14.8,
        lcr_ratio=125.5,
        nsfr_ratio=112.3,
        npl_ratio=2.1,
        roe=11.5
    )

@router.get("/metrics/insurance")
async def get_insurance_metrics() -> InsuranceMetrics:
    """Retourne les m√©triques d'assurance actuelles"""
    return InsuranceMetrics(
        scr_ratio=168.0,
        mcr_ratio=672.0,
        combined_ratio=94.5,
        loss_ratio=62.3,
        expense_ratio=32.2
    )